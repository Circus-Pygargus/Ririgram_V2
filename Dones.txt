en ssh :
Mise à jour
    sudo apt-get update
    sudo apt-get upgrade -y

installation de curl, sert en autres à charger des fichiers
    sudo apt-get -y install curl

instalaltion de git
    sudo apt-get -y install git

instalaltion de zip
    sudo apt-get -y install zip 
    sudo apt-get -y install unzip

installation de nodejs (vu sur cette page : https://github.com/nodesource/distributions)
    curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -
    sudo apt-get install -y nodejs

    node -v
        |->     v14.7.0

le projet Ririgram_V2 est géjà créé sur github avec readme et gitignore nodejs, donc
    cd /var/www/html/
    git config --global user.name "Circus-Pygargus"
    git config --global user.email "richard.meuret@laposte.net"
    git clone https://github.com/Circus-Pygargus/Ririgram_V2.git ./

on a besoin de npm dans ce dossier, donc 
    npm init
je lui donne en réponse :
    ririgram        pour le nom
et je fais entrée pour tout le reste.
et il me crée un chouette fichier package.json


installation de mongodb :
A cette page : https://www.mongodb.com/download-center/community
on choisit la version MongoDB Community Server
pas oublier de choisir l'OS, ici Ubuntu 18.04 Linux x64
on choisit le package TGZ
et on peut charger
toujours dans windows, j'extrais le dossier du fichier tgz, le colle dans app et le renomme en mongodb.
il faut maintenant le déplacer dans le dossier user de la VM :
    mv /var/www/html/mongodb ~/mongodb

on va faire également un dossier pour stoquer la/les base de données, on se colle dans user encore (où se situe le dossier mongodb, d'ailleurs il s'attend à trouver ce dossier à coté de lui)
    cd ~
    mkdir mongobd-data

pour connaître le chemin vers mongodb si on ne le connait pas, il suffit de faire :
    cd ~
    pwd
        |-> /home/vagrant

On va démarrer mongodb en lui expliquant où se trouve le dossier à utiliser pour stocker les données :
    /home/vagrant/mongodb/bin/mongod --dbpath=/home/vagrant/mongodb-data
il retourne de nombreuses infos, une ligne en particulier nous intéresse; elle nous donne le port utilisé, 
chercher dans les dernières lignes, il y en a trois relative au NETWORK, on a besoin de celle-ci :        
        2020-05-27T00:01:11.730+0000 I  NETWORK  [listener] waiting for connections on port 27017
on fera donc nos demandes sur le port 27017 ;)


on va avoir besoin du driver pour accéder à la base de données selon notre langage, ici nodejs (lol un langage)
depuis la page : https://www.mongodb.com/
on cherche doc -> drivers et on choisit NodeJs


j'ouvre un deuxième terminal pour pouvoir écrire d'autres commandes

donc on veux pouvoir communiquer avec la bdd et il nous faut un driver pour nodejs, on va utiliser un module (driver) npm : mongodb
dans /var/www/html :
    npm install mongodb --save --no-bin-links


On va utiliser le module npm mongoose, il servira entre autre à gérer nos models, validation ... pour la bdd
    npm i mongoose

Création du fichier app/src/db/mongoose.js
j'y colle ça :
    const mongoose = require('mongoose');
    // here ririgram is the name of the database
    mongoose.set('useNewUrlParser', true)
    mongoose.set('useUnifiedTopology', true)
    mongoose.set('useCreateIndex', true)
    mongoose.set('useFindAndModify', false)
    mongoose.connect('mongodb://127.0.0.1:27017/ririgram');
    // used during development when need to delete the database
    // const connection = mongoose.connection;
    // connection.once("open", () => {
    //     console.log('*** MongoDB got connected ! ***')
    //     console.log(`Our Current DataBase Name : ${connection.db.databaseName}`)
    //     mongoose.connection.db.dropDatabase(
    //         console.log(`${connection.db.dababaseName} database dropped.`)
    //     )
    // });
puis pour tester :
    cd /src/db
    node mongoose.js
        |->     *** MongoDB got connected ! ***
                Our Current DataBase Name : ririgram
ok 



on va avoir besoin de express pour nos requêtes http et les routes, donc
    npm i express --no-bin-links

Création du fichier principal de l'appli : app/src/index.js
j'y colle :
    const express = require('express');
    // call mongoose.js, it will launch the file, connect to db and create database if doesn't exist
    require('./db/mongoose');
    // importing routes 
    // not created yet
    const userRouter = require('./routers/user');
    // const gridRouter = require('./routers/grid');
    // const optionsRouter = require('./routers/options'):
    const app = express();
    // for dev in vagrant 
    const hostname = '192.168.0.50';
    // used port
    const port = 3002;
    // Tell express to parse json when we receice some (NEEDED for POST requests !)
    app.arguments(express.json());
    // register our routes in express
    app.use(userRouter);
    // app.use(gridRouter);
    // app.use(optionsRouter);
    // Launch server
    app.listen(port, hostName, () => {
        console.log(`Server is up at ${hostname}:${port}`);
    });

Création du router pour user : /app/src/routers/user.js



pour pouvoir utiliser des pages dynamiques, on va avoir besoin du module npm handlebars
    npm i hbs --no-bin-links
création du dossier /app/public/
création du dossier /app/templates/views/
création du dossier /app/templates/partials/
dans index.js, j'ajoute ces lignes : (gaffe c'est pas placé n'importe où -voir index.js - )
    const path = require('path');
    const hbs = require('hbs');
    const publicDirectoryPath = path.join(__dirname, '../public');
    const viewsPath = path.join(__dirname, '../templates/views');
    const partialPath = path.join(__dirname, '../templates/partials');
    app.set('view engine', 'hbs');
    app.set('views', viewsPath);
    hbs.registerPartials(partialPath);

pour tester tout ça, je vais ajouter une page 404:
ajout dans index.js 
    app.get('*', (req, res) => {
        res.render('404', {
            title: 'ririgram',
            author: 'Richard Meuret',
            message404: 'Page non trouvée !'
        });
    });
création de la vue : app/templates/views/404.hbs



pour gérer les utilisateur, on va avoir besoin d'un modèle,
et pour que mongoose puisse valider ce qu'il recevra, il nous faut le module npm validator
    npm i validator --no-bin-links
pour chiffre les mot de passe on va utiliser le module npm bcryptjs
    npm i bcryptjs --no-bin-links
et pour gérer les token on va utiliser le module npm jsonwebtoken
    npm i jsonwebtoken --no-bin-links

création du fichier : /app/src/models/user.js
on va aussi avoir besoin d'authentifier les users, 
création du fichier : app/src/middleware/auth.js


Creation du fichier app/src/routers/user.js
j'y colle juste la route de création d'utilisateur

corrections de quelques erreurs
tests effectués via Postman : ok ça roule


création du fichier /src/models/options.js
création du fichier /app/default_values/colors.js

utilisation de ces 2 fichiers dans routers/user.js avec la mise en place de la route Login User

correction dans models.user.js
    userSchema.methods.ToJSON
par 
    userSchema.methods.toJSON

tests via Postman, lors du login, si pas d'options enregistrées pour cet user -> on envoie les options par défaut --> nickel

création des routes Logout User et LogoutAll User
vérif via postamn que les tokens sont bien effacés comme prévu

création du fichier src/routers/options et ajout de la route Options List

modification dans app/src/index.js de la route 404 : ajout de l'envoi du status 404 avec la page


ci-dessous annulé:
ajout de la route /login dans src/index.jsje sais que ça devrait être dans routers/users/ mais je veux juste faire un rendu d'un partial et c'est beacoup plus simple si pas dans un nested router, surtout qu'ici je vais envoyer le formulaire et un lien vers la route /signin

nan je vais plutôt tout envoyer (les deux formulaires) avec src/index.js planquer les formulaires et faire de chouettes transitions avec les clics sur les divs de la nav, du genre :

svg login     Connexion
    caché / affichage en déroulant (ou autre si mieux ^^) :
    formulaire de log
svg signin    Nouveau Joueur
    caché / affichage en déroulant (ou autre si mieux ^^) :
    formulaire de création de compte
svg jouer     Jouer
    caché / affichage en déroulant (ou autre si mieux ^^) :
    Attention jeux restrain, juste pour test, sûr ?
svg help      Aide
    caché / affichage en déroulant (ou autre si mieux ^^) ou lien vers /help ???

et si le jeu est choisi, on affiche juste un petite roue crantée qui permettra de réafficher la nav bar avant une fin de partie

mise en place d'un fullscreen toggle dans la barre de titre :
création du template partiel header.hbs
création du fichier /public/js/fullscreen-toggle.js
création du fichier /public/scss/header.scss


ajout nav bar pour user non loggué :
création fichier templates/partials/navNotLogged.hbs
création fichier public/css/user-not-logged.scss


création fichier public/js/nav-not-logged.js
création fichier public/css/variables.scss
et mise en forme avec couleurs de la page d'accueil


Déplacement du contenu du fichier public/js/nav-not-logged.js ver le nouveau fichier public/js/navbars.js
Ce script est en commun à toutes les navbars et sert uniquement à afficher leur contenus

ajout dans navbars.js, desselection si reclic sur bouton de nav

modif de navbars.js pour en faire une constante appelable à chaque fois que l'on change de navbar

ajout requête post pour /user/login dans public/js/nav-not-logged.js 
modif routers/user.js pour gestion de partial template
Création du partial navLogged.hbs juste pour test le token
c'est ok


modif du contenu de navLogged.hbs, de nav-not-logged.js et user-not-logged.scss

modif du style de la div #welcome (accueil nouvel inscrit ou joueur juste après login)

renommé le fichier user-not-logged.scss en navbars.scss puisque pour les 2 navbars =)


ajout vérification de la disponibilité de sessionStorage sur le navigateur via public/js/is-storage-available.js et une petite partie dans public/js/index.js


Ajout requêtes /users/logout et /users/logoutall dans public/js/nav-logged.js

Création du fichier /src/utils/compute-grid-solution.js
Création du fichier /src/utils/compute-helpers.js

Création du fichier src/routers/grid.js de la route /grid/test-play

modif div Jouer dans nav-not-logged (class="button" et modif scss)

Ajout d'un svg (gear) dans le header qui servira à afficher/cacher la navbar lors d'une partie ou pendant le parcours des grilles
Création du fichier public/js/toggle-navbar.js
ajout remise en forme de la navbar lors d'un clic sur toggleNavbarBtn

mise en place de la requête /grid/test-game dans public/js/nav-not-logged.js

création du fichier css-variables.js et de la méthode permettant de calculer la taille de la grille en fonction de la taille de l'écran
ajout gestion de non status 201 sur cette requête

Création du fichier public/js/gameboard-builder.js

Création du fichier public/js/game-manager.js
ce dernier servira a fabriquer la grille, recalculer les variables css de taille de grille en cas de changement de la taille de l'écran (redimentionnement sur pc, changement d'orientation sur mobile/tablette), observer l'évolution de la grille pour savoir s'il faut envoyer la grille au serveur ...

Modif dans création html de grille, gameboardDiv maintenant dans mainContent

Création du fichier public/css/gameboard.scss

Ajout des boutons de choix de réponse dans index.hbs et mise en place de leur réaction au clic

Cache ces boutons si pas en partie.

Ajouté: bordure plus grosexit
se toutes les 5 cases de la grille verticalement.

Ajout réaction au clic de case de la grille.

Retiré : affichage du context menu si clic droit, sélection de texte via clic gauche déplacé et mouvement d'écran si touchmove (écrans tactiles)

retiré : scroll de page si clic sur bouton du milieu de la souris

Ajout gestion victoire si test-game

gestion des bouton de fermeture et de nouvelle grille de victoryDiv

ajout éclairage des headers de la grille au survol de case par la souris, dans public/js/gamemanager.js

création de la croix de navigation pour la grille

repositionnement des boutons de jeu pour mobile

retiré le bug qui enlevait la couleur d'une tuile lors d'une sélection multiple 

ajout déselection multiple sans modif des autres choix que celui en cours

cache la croix pour la grille si clic sur bouton fermer de Victory

ajout gestion de isUsingCross (game manager)

gestion du onhover sur les cases de la grille en js en ajoutant un classe, plutôt qu'un css tile:hover, pour ne pas modifier l'affichage de la case en cours lors d'un survol de souris si utilisation de la croix ( ou du peut-être un jour du gamepad ;) )
j'en ai profité pour modifier la gestion du nettoyage du css cols ou rowheaders.enlight coté js
De plus refactorisation du code en virant le tile.addEventListener('mouseover') et en utilisant son code dans tile.addEventListener('mouseenter')

réécriture de la croix de nav de la grille en un seul svg au lieu de 4, permettant ainsi son redimentionnement si .not-in-use

retiré : l'incrémentation du nbr de clic si isRemovingChoice ou si old choice != default et changement pour no ou maybe-no

Ajout selection de case avec la game cross

début utilisation game cross, pas convainquant, une seule case à la fois ...

résolu bug qui empéchait la sélection d'un bouton de couleur sur écran tactile (du au event.preventDefault() sur un touchstart qui empéchait l'event click d'être lancé)

modification game cross : maintenant la case sélectionnée change régulièrement lors d'un appui long

amélioration game cross : changement de choix sur les cases si appui long sur un choiceButton et sur la croix

ajout : comptage du nombre de 'clic' en utilisant la game cross
bug: 
    _ deux cases selected lors d'un rappel de partie en test depuis le menu principal après victory (que sur phone ?)
    _ pire la deuxième bouge toute seule apres appui long ...


Création branche dev

création branche testeventfunctions
j'y ai testé l'utilisation de function pour le addEventListener pour pouvoir utiliser des removeEventListener, 
ça fonctionnait mais juste une fois ...


bascule sur la branche dev
bug réglé ! maintenant il semble qu'on peut utiliser la croix correctement =)
pb, je trouve le code super moche !! faudra voir à regarder ça à nouveau ...

tentative sur dev d'ajouter la selection de plusieurs case avec un seul mouvement de doigt ... marche pas ...
je crois bien que la soluce va être de calculer le point d'arrivée du doigt puis la longueur de déplacement, et calculer quelles sont les cases touchées en cours de route ...

gestion de la route post /users (register user) coté front (sauf gestion retour des erreurs)

Création des modèles grid, userTimeEasy et userTimeHard

Ajout de la route /grid/new
création du modèle startTime pour enregistrer l'heure de début de jeu sur une grille pour un joueur

modification formulaire nouvelle partie dans user-loggued.js

pour l'instant je vais forcer à jouer uniquement sur des grilles carrées ...
mise en place rowsNb = colsNb coté front avec le formulaire nouvelle partie de user-logged.js
idem coté back avec ajout de forceSquareGrid dans routers/grid.js

gestion de la requête /grid/new dans user-logged.js

ajout vérif de grille pour si user logged, on va vérifier que les nombres de cases par ligne/colonne correspondent avec les totaux des headers. mais ça devrait pas être définitif, il faudra l'echanger par un contrôle des correspondances entre les helpers et la réalité de la grille, pas juste le nombre total correspondant. 
Pour faire plus simple encore, j'ai utilisé le nombre de clics pour une partie sans faute (clicksNbForPerfectGame)

modif : ajout l'envoi de grid._id depuis la route /grid/new et réception dans nav-logged.js puis game-manager.js

Ajout : route /grid/check pour vérifier les grilles finies par les joueurs

Correction bug : dans la route /grid/new on récupérait une grille déjà jouée

Ajout public/js/failed.js
    pour les partie envoyée au serveur mais fausse

Ajout gestion fetch pour /grid/check

correction bug : si user not logged et redemande test-game depuis victory, il fait autant d'appel que de fois où l'on a appuyé sur 'encore' ... : 
    retiré victoryPlayAnother.addEventListener('click'..  de la méthode watchVictoryBtns()

Déplacememnt du fetch /grid/new de nav-logged.js dans une constante à part pour pouvoir l'appeler depuis victory.
Ajout gestion bouton nouvelle partie si isUserLogged avec appel de cette constante nouvellement crée.

Création d'un partials : rules.hbs
    j'y afficherai les règles du jeu et les infos via des onglets séparés,
    pour l'instant juste quelques infos

Reconstruction complète de l'ancienne partie 'Règles':
Création des partial views : social, rules, infos et feedback
    maintenant l'onglet global 'Infos et +' laisse apparaître 3 sous-menus : Règles, Infos et Messages

Ajout contenu à partials/feedback

Création du partial messages.hbs : il servira à afficher les feedback envoyés par les joueurs.

Création du modèle Feedback, qui permettra d'enregistrer les messages des joueurs en BDD

Création du router feedback.js

modif : ajout possibilité de réponse aux feedbacks

implémenté : seul le créateur d'un message peut voir le bouton de suppression de message






A FAIRE : 
_ le bouton répondre au feedback devrait n'être visible que par l'admin !
_ le bouton effacer un feedback ne devrait être visible que par le créateur !





// !!! Ne pas oublier d'ajouter 'Bearer ' devant les tokens coté front avant de les envoyer au serveur !!!!


pour lancer mongodb :
    /home/vagrant/mongodb/bin/mongod --dbpath=/home/vagrant/mongodb-data
pour lancer l'appli
    node src/index.js
ou 
    npm run start



users during dev :
{
    "name": "Circus",
    "email": "fauxmail@pour.test",
    "password": "1234567"
}

{
    "name": "Circus2",
    "email": "fauxmail2@pour.test",
    "password": "12345678"
}

{
    "name": "Circus3",
    "email": "fauxmail3@pour.test",
    "password": "1234567"
}

todos :
_ faire une requête après réception du résultat positif de test de grille et envoyer le vote pour la grille
_ écrire la méthode checkTileHeaders() dans public/js/game-manager.js pour modif la couleur des helpers qd correspodant à la grille et utiliser une correspondance complète pour envoi de la grille au serveur pour vérif.
    une fois fait, retirer clicksNbForPerfectGame de l'envoi en res du serveur dans la route /grid/new, plus besoin de lui ;); le retirer aussi dans nav-logged.js, dans newGdridForm -> submit. --attention-- ne pas le virer en réception coté front dans gamemanager ... on s'en sert avec test-game.
_ ajouter la gestion d'un gamepad pour faire comme la croix mais sur pc ? ce serait top !
_ ajouter : message d'erreur : cet email est déjà enregistré (models/use.js ) déjà fait et pourtant fonctionne pas ...
_ ajouter retour vérif création new user, qd name existe on a pas le mesage d'erreur perso mais e.code = 11000 et e.keyValue = { name: 'Circus' } je devrais pouvoir utiliser ça
_ ajouter si login, vérif token car on ne devrait pas avoir accès au form de login une fois loggué -> avertissement pour pratique étrange ? -> ban ip, email  pour un temps -> ban ip, email pour toujours ?
_ gràce au token, faire un se souvenir de moi ? 
    au moins coller une date d'expiration sur les tokens
_ ajouter un rôle dans la bdd User, je vais pas faire un isAdmin, mais plutôt un role='admin' ça permettra de ne pas faire tomber la base de données pour ajout d'un éventuel rôle plus tard ;)
_ ajouter dans nav-not- logged : mot de passe oublié avec envoi mail de confirmation
_ ajouter gestion des erreurs form login (et les autres)


idées: 
_ Victory : 
    au lieu de faire des phrases, faire quelque chose comme ça ? :

    Nbr de coups : 19
    |
    |-> Sans faute : Check    (ou perfect game ?)
    ou  Nbr coups mini : 17

    Chrono : 1:25:365
    |
    |-> Record du monde : Check
    ou  Record du monde : 1:22:654
        par Duchnock
    ou  rien si premier chrono pour cette grille



DB feedback :
    type
    device
    browser
    message