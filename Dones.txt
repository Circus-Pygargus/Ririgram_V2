en ssh :
Mise à jour
    sudo apt-get update
    sudo apt-get upgrade -y

installation de curl, sert en autres à charger des fichiers
    sudo apt-get -y install curl

instalaltion de git
    sudo apt-get -y install git

instalaltion de zip
    sudo apt-get -y install zip 
    sudo apt-get -y install unzip

installation de nodejs (vu sur cette page : https://github.com/nodesource/distributions)
    curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -
    sudo apt-get install -y nodejs

    node -v
        |->     v14.7.0

le projet Ririgram_V2 est géjà créé sur github avec readme et gitignore nodejs, donc
    cd /var/www/html/
    git config --global user.name "Circus-Pygargus"
    git config --global user.email "richard.meuret@laposte.net"
    git clone https://github.com/Circus-Pygargus/Ririgram_V2.git ./

on a besoin de npm dans ce dossier, donc 
    npm init
je lui donne en réponse :
    ririgram        pour le nom
et je fais entrée pour tout le reste.
et il me crée un chouette fichier package.json


installation de mongodb :
A cette page : https://www.mongodb.com/download-center/community
on choisit la version MongoDB Community Server
pas oublier de choisir l'OS, ici Ubuntu 18.04 Linux x64
on choisit le package TGZ
et on peut charger
toujours dans windows, j'extrais le dossier du fichier tgz, le colle dans app et le renomme en mongodb.
il faut maintenant le déplacer dans le dossier user de la VM :
    mv /var/www/html/mongodb ~/mongodb

on va faire également un dossier pour stoquer la/les base de données, on se colle dans user encore (où se situe le dossier mongodb, d'ailleurs il s'attend à trouver ce dossier à coté de lui)
    cd ~
    mkdir mongobd-data

pour connaître le chemin vers mongodb si on ne le connait pas, il suffit de faire :
    cd ~
    pwd
        |-> /home/vagrant

On va démarrer mongodb en lui expliquant où se trouve le dossier à utiliser pour stocker les données :
    /home/vagrant/mongodb/bin/mongod --dbpath=/home/vagrant/mongodb-data
il retourne de nombreuses infos, une ligne en particulier nous intéresse; elle nous donne le port utilisé, 
chercher dans les dernières lignes, il y en a trois relative au NETWORK, on a besoin de celle-ci :        
        2020-05-27T00:01:11.730+0000 I  NETWORK  [listener] waiting for connections on port 27017
on fera donc nos demandes sur le port 27017 ;)


on va avoir besoin du driver pour accéder à la base de données selon notre langage, ici nodejs (lol un langage)
depuis la page : https://www.mongodb.com/
on cherche doc -> drivers et on choisit NodeJs


j'ouvre un deuxième terminal pour pouvoir écrire d'autres commandes

donc on veux pouvoir communiquer avec la bdd et il nous faut un driver pour nodejs, on va utiliser un module (driver) npm : mongodb
dans /var/www/html :
    npm install mongodb --save --no-bin-links


On va utiliser le module npm mongoose, il servira entre autre à gérer nos models, validation ... pour la bdd
    npm i mongoose

Création du fichier app/src/db/mongoose.js
j'y colle ça :
    const mongoose = require('mongoose');
    // here ririgram is the name of the database
    mongoose.set('useNewUrlParser', true)
    mongoose.set('useUnifiedTopology', true)
    mongoose.set('useCreateIndex', true)
    mongoose.set('useFindAndModify', false)
    mongoose.connect('mongodb://127.0.0.1:27017/ririgram');
    // used during development when need to delete the database
    // const connection = mongoose.connection;
    // connection.once("open", () => {
    //     console.log('*** MongoDB got connected ! ***')
    //     console.log(`Our Current DataBase Name : ${connection.db.databaseName}`)
    //     mongoose.connection.db.dropDatabase(
    //         console.log(`${connection.db.dababaseName} database dropped.`)
    //     )
    // });
puis pour tester :
    cd /src/db
    node mongoose.js
        |->     *** MongoDB got connected ! ***
                Our Current DataBase Name : ririgram
ok 



on va avoir besoin de express pour nos requêtes http et les routes, donc
    npm i express --no-bin-links

Création du fichier principal de l'appli : app/src/index.js
j'y colle :
    const express = require('express');
    // call mongoose.js, it will launch the file, connect to db and create database if doesn't exist
    require('./db/mongoose');
    // importing routes 
    // not created yet
    const userRouter = require('./routers/user');
    // const gridRouter = require('./routers/grid');
    // const optionsRouter = require('./routers/options'):
    const app = express();
    // for dev in vagrant 
    const hostname = '192.168.0.50';
    // used port
    const port = 3002;
    // Tell express to parse json when we receice some (NEEDED for POST requests !)
    app.arguments(express.json());
    // register our routes in express
    app.use(userRouter);
    // app.use(gridRouter);
    // app.use(optionsRouter);
    // Launch server
    app.listen(port, hostName, () => {
        console.log(`Server is up at ${hostname}:${port}`);
    });

Création du router pour user : /app/src/routers/user.js



pour pouvoir utiliser des pages dynamiques, on va avoir besoin du module npm handlebars
    npm i hbs --no-bin-links
création du dossier /app/public/
création du dossier /app/templates/views/
création du dossier /app/templates/partials/
dans index.js, j'ajoute ces lignes : (gaffe c'est pas placé n'importe où -voir index.js - )
    const path = require('path');
    const hbs = require('hbs');
    const publicDirectoryPath = path.join(__dirname, '../public');
    const viewsPath = path.join(__dirname, '../templates/views');
    const partialPath = path.join(__dirname, '../templates/partials');
    app.set('view engine', 'hbs');
    app.set('views', viewsPath);
    hbs.registerPartials(partialPath);

pour tester tout ça, je vais ajouter une page 404:
ajout dans index.js 
    app.get('*', (req, res) => {
        res.render('404', {
            title: 'ririgram',
            author: 'Richard Meuret',
            message404: 'Page non trouvée !'
        });
    });
création de la vue : app/templates/views/404.hbs



pour gérer les utilisateur, on va avoir besoin d'un modèle,
et pour que mongoose puisse valider ce qu'il recevra, il nous faut le module npm validator
    npm i validator --no-bin-links
pour chiffre les mot de passe on va utiliser le module npm bcryptjs
    npm i bcryptjs --no-bin-links
et pour gérer les token on va utiliser le module npm jsonwebtoken
    npm i jsonwebtoken --no-bin-links

création du fichier : /app/src/models/user.js
on va aussi avoir besoin d'authentifier les users, 
création du fichier : app/src/middleware/auth.js


Creation du fichier app/src/routers/user.js
j'y colle juste la route de création d'utilisateur

corrections de quelques erreurs
tests effectués via Postman : ok ça roule


création du fichier /src/models/options.js
création du fichier /app/default_values/colors.js

utilisation de ces 2 fichiers dans routers/user.js avec la mise en place de la route Login User

correction dans models.user.js
    userSchema.methods.ToJSON
par 
    userSchema.methods.toJSON

tests via Postman, lors du login, si pas d'options enregistrées pour cet user -> on envoie les options par défaut --> nickel

création des routes Logout User et LogoutAll User
vérif via postamn que les tokens sont bien effacés comme prévu

création du fichier src/routers/options et ajout de la route Options List

modification dans app/src/index.js de la route 404 : ajout de l'envoi du status 404 avec la page


ci-dessous annulé:
ajout de la route /login dans src/index.jsje sais que ça devrait être dans routers/users/ mais je veux juste faire un rendu d'un partial et c'est beacoup plus simple si pas dans un nested router, surtout qu'ici je vais envoyer le formulaire et un lien vers la route /signin

nan je vais plutôt tout envoyer (les deux formulaires) avec src/index.js planquer les formulaires et faire de chouettes transitions avec les clics sur les divs de la nav, du genre :

svg login     Connexion
    caché / affichage en déroulant (ou autre si mieux ^^) :
    formulaire de log
svg signin    Nouveau Joueur
    caché / affichage en déroulant (ou autre si mieux ^^) :
    formulaire de création de compte
svg jouer     Jouer
    caché / affichage en déroulant (ou autre si mieux ^^) :
    Attention jeux restrain, juste pour test, sûr ?
svg help      Aide
    caché / affichage en déroulant (ou autre si mieux ^^) ou lien vers /help ???

et si le jeu est choisi, on affiche juste un petite roue crantée qui permettra de réafficher la nav bar avant une fin de partie

mise en place d'un fullscreen toggle dans la barre de titre :
création du template partiel header.hbs
création du fichier /public/js/fullscreen-toggle.js
création du fichier /public/scss/header.scss


ajout nav bar pour user non loggué :
création fichier templates/partials/navNotLogged.hbs
création fichier public/css/user-not-logged.scss


création fichier public/js/nav-not-logged.js
création fichier public/css/variables.scss
et mise en forme avec couleurs de la page d'accueil


Déplacement du contenu du fichier public/js/nav-not-logged.js ver le nouveau fichier public/js/navbars.js
Ce script est en commun à toutes les navbars et sert uniquement à afficher leur contenus

ajout dans navbars.js, desselection si reclic sur bouton de nav

modif de navbars.js pour en faire une constante appelable à chaque fois que l'on change de navbar

ajout requête post pour /user/login dans public/js/nav-not-logged.js 
modif routers/user.js pour gestion de partial template
Création du partial navLogged.hbs juste pour test le token
c'est ok


modif du contenu de navLogged.hbs, de nav-not-logged.js et user-not-logged.scss

modif du style de la div #welcome (accueil nouvel inscrit ou joueur juste après login)

renommé le fichier user-not-logged.scss en navbars.scss puisque pour les 2 navbars =)


ajout vérification de la disponibilité de sessionStorage sur le navigateur via public/js/is-storage-available.js et une petite partie dans public/js/index.js


Ajout requêtes /users/logout et /users/logoutall dans public/js/nav-logged.js

Création du fichier /src/utils/compute-grid-solution.js
Création du fichier /src/utils/compute-helpers.js

Création du fichier src/routers/grid.js de la route /grid/test-play

modif div Jouer dans nav-not-logged (class="button" et modif scss)

Ajout d'un svg (gear) dans le header qui servira à afficher/cacher la navbar lors d'une partie ou pendant le parcours des grilles
Création du fichier public/js/toggle-navbar.js
ajout remise en forme de la navbar lors d'un clic sur toggleNavbarBtn

mise en place de la requête /grid/test-game dans public/js/nav-not-logged.js









// !!! Ne pas oublier d'ajouter 'Bearer ' devant les tokens coté front avant de les envoyer au serveur !!!!


pour lancer mongodb :
    /home/vagrant/mongodb/bin/mongod --dbpath=/home/vagrant/mongodb-data
pour lancer l'appli
    node src/index.js
ou 
    npm run start



users during dev :
{
    "name": "Circus",
    "email": "fauxmail@pour.test",
    "password": "1234567"
}

{
    "name": "Circus2",
    "email": "fauxmail2@pour.test",
    "password": "12345678"
}

todos :
_ ajouter : message d'erreur : cet email est déjà enregistré (models/use.js ) déjà fait et pourtant fonctionne pas ...
_ ajouter retour vérif création new user, qd name existe on a pas le mesage d'erreur perso mais e.code = 11000 et e.keyValue = { name: 'Circus' } je devrais pouvoir utiliser ça
_ ajouter si login, vérif token car on ne devrait pas avoir accès au form de login une fois loggué -> avertissement pour pratique étrange ? -> ban ip, email  pour un temps -> ban ip, email pour toujours ?
_ gràce au token, faire un se souvenir de moi ? 
    au moins coller une date d'expiration sur les tokens
_ ajouter un rôle dans la bdd User, je vais pas faire un isAdmin, mais plutôt un role='admin' ça permettra de ne pas faire tomber la base de données pour ajout d'un éventuel rôle plus tard ;)
_ ajouter dans nav-not- logged : mot de passe oublié avec envoi mail de confirmation
_ ajouter gestion des erreurs form login (et les autres)



méthode requete grille user logged :
router(grid, auth, (req, res) => {
    si auth ok
    recherche de grille en bdd non jouée par le joueur (ne pas oublier la difficulté)
    si !grille -> création complète de grille
        enregistrement grille en bdd
        envoi de la grille
    si grille -> envoi de la grille
})


méthode requete grille user not logged :
router(grid, (req, res) => {
    création grille complète en 4*4
    envoi de la grille
})


Grid = {
    _id,
    gridSolution,
    clicksNbsForPerfectGame,
    rowsHelpers,
    maxRowsHelpers,
    colsHelpers,
    maxRowsHelpers,
    creator, // ref User
    bestTimeEasy, // ref UserTimeEasy.besTime
    bestTimeHard, // ref UserTimeEasy.besTime
    votes: {
        nbVote-1, // worst note
        nbVote-2, // bad
        nbVote-3, // neutral
        nbVote-4, // good
        nbVote-5, // best note
        nbVotes,
        average
    },
    timeStamps
}

UserTimeEasy = {
    _id,
    bestTime, // can be null
    lastTime, // can be null
    userGrid, // un truc genre user._id + grid._id pour ne pas avoir de doublons // nan la suite devrait suffire
    grid, // ref Grid
    owner, // ref User
    vote, // can be null
    timeStamps
}

UserTimeHard = { voir ci-dessus }