en ssh :
Mise à jour
    sudo apt-get update
    sudo apt-get upgrade -y

installation de curl, sert en autres à charger des fichiers
    sudo apt-get -y install curl

instalaltion de git
    sudo apt-get -y install git

instalaltion de zip
    sudo apt-get -y install zip 
    sudo apt-get -y install unzip

installation de nodejs (vu sur cette page : https://github.com/nodesource/distributions)
    curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -
    sudo apt-get install -y nodejs

    node -v
        |->     v14.7.0

le projet Ririgram_V2 est géjà créé sur github avec readme et gitignore nodejs, donc
    cd /var/www/html/
    git config --global user.name "Circus-Pygargus"
    git config --global user.email "richard.meuret@laposte.net"
    git clone https://github.com/Circus-Pygargus/Ririgram_V2.git ./

on a besoin de npm dans ce dossier, donc 
    npm init
je lui donne en réponse :
    ririgram        pour le nom
et je fais entrée pour tout le reste.
et il me crée un chouette fichier package.json


installation de mongodb :
A cette page : https://www.mongodb.com/download-center/community
on choisit la version MongoDB Community Server
pas oublier de choisir l'OS, ici Ubuntu 18.04 Linux x64
on choisit le package TGZ
et on peut charger
toujours dans windows, j'extrais le dossier du fichier tgz, le colle dans app et le renomme en mongodb.
il faut maintenant le déplacer dans le dossier user de la VM :
    mv /var/www/html/mongodb ~/mongodb

on va faire également un dossier pour stoquer la/les base de données, on se colle dans user encore (où se situe le dossier mongodb, d'ailleurs il s'attend à trouver ce dossier à coté de lui)
    cd ~
    mkdir mongobd-data

pour connaître le chemin vers mongodb si on ne le connait pas, il suffit de faire :
    cd ~
    pwd
        |-> /home/vagrant

On va démarrer mongodb en lui expliquant où se trouve le dossier à utiliser pour stocker les données :
    /home/vagrant/mongodb/bin/mongod --dbpath=/home/vagrant/mongodb-data
il retourne de nombreuses infos, une ligne en particulier nous intéresse; elle nous donne le port utilisé, 
chercher dans les dernières lignes, il y en a trois relative au NETWORK, on a besoin de celle-ci :        
        2020-05-27T00:01:11.730+0000 I  NETWORK  [listener] waiting for connections on port 27017
on fera donc nos demandes sur le port 27017 ;)


on va avoir besoin du driver pour accéder à la base de données selon notre langage, ici nodejs (lol un langage)
depuis la page : https://www.mongodb.com/
on cherche doc -> drivers et on choisit NodeJs


j'ouvre un deuxième terminal pour pouvoir écrire d'autres commandes

donc on veux pouvoir communiquer avec la bdd et il nous faut un driver pour nodejs, on va utiliser un module (driver) npm : mongodb
dans /var/www/html :
    npm install mongodb --save --no-bin-links


On va utiliser le module npm mongoose, il servira entre autre à gérer nos models, validation ... pour la bdd
    npm i mongoose

Création du fichier app/src/db/mongoose.js
j'y colle ça :
    const mongoose = require('mongoose');
    // here ririgram is the name of the database
    mongoose.set('useNewUrlParser', true)
    mongoose.set('useUnifiedTopology', true)
    mongoose.set('useCreateIndex', true)
    mongoose.set('useFindAndModify', false)
    mongoose.connect('mongodb://127.0.0.1:27017/ririgram');
    // used during development when need to delete the database
    // const connection = mongoose.connection;
    // connection.once("open", () => {
    //     console.log('*** MongoDB got connected ! ***')
    //     console.log(`Our Current DataBase Name : ${connection.db.databaseName}`)
    //     mongoose.connection.db.dropDatabase(
    //         console.log(`${connection.db.dababaseName} database dropped.`)
    //     )
    // });
puis pour tester :
    cd /src/db
    node mongoose.js
        |->     *** MongoDB got connected ! ***
                Our Current DataBase Name : ririgram
ok 



on va avoir besoin de express pour nos requêtes http et les routes, donc
    npm i express --no-bin-links

Création du fichier principal de l'appli : app/src/index.js
j'y colle :
    const express = require('express');
    // call mongoose.js, it will launch the file, connect to db and create database if doesn't exist
    require('./db/mongoose');
    // importing routes 
    // not created yet
    const userRouter = require('./routers/user');
    // const gridRouter = require('./routers/grid');
    // const optionsRouter = require('./routers/options'):
    const app = express();
    // for dev in vagrant 
    const hostname = '192.168.0.50';
    // used port
    const port = 3002;
    // Tell express to parse json when we receice some (NEEDED for POST requests !)
    app.arguments(express.json());
    // register our routes in express
    app.use(userRouter);
    // app.use(gridRouter);
    // app.use(optionsRouter);
    // Launch server
    app.listen(port, hostName, () => {
        console.log(`Server is up at ${hostname}:${port}`);
    });

Création du router pour user : /app/src/routers/user.js



pour pouvoir utiliser des pages dynamiques, on va avoir besoin du module npm handlebars
    npm i hbs --no-bin-links
création du dossier /app/public/
création du dossier /app/templates/views/
création du dossier /app/templates/partials/
dans index.js, j'ajoute ces lignes : (gaffe c'est pas placé n'importe où -voir index.js - )
    const path = require('path');
    const hbs = require('hbs');
    const publicDirectoryPath = path.join(__dirname, '../public');
    const viewsPath = path.join(__dirname, '../templates/views');
    const partialPath = path.join(__dirname, '../templates/partials');
    app.set('view engine', 'hbs');
    app.set('views', viewsPath);
    hbs.registerPartials(partialPath);

pour tester tout ça, je vais ajouter une page 404:
ajout dans index.js 
    app.get('*', (req, res) => {
        res.render('404', {
            title: 'ririgram',
            author: 'Richard Meuret',
            message404: 'Page non trouvée !'
        });
    });
création de la vue : app/templates/views/404.hbs



pour gérer les utilisateur, on va avoir besoin d'un modèle,
et pour que mongoose puisse valider ce qu'il recevra, il nous faut le module npm validator
    npm i validator --no-bin-links
pour chiffre les mot de passe on va utiliser le module npm bcryptjs
    npm i bcryptjs --no-bin-links
et pour gérer les token on va utiliser le module npm jsonwebtoken
    npm i jsonwebtoken --no-bin-links

création du fichier : /app/src/models/user.js
on va aussi avoir besoin d'authentifier les users, 
création du fichier : app/src/middleware/auth.js


Creation du fichier app/src/routers/user.js
j'y colle juste la route de création d'utilisateur

corrections de quelques erreurs
tests effectués via Postman : ok ça roule


création du fichier /src/models/options.js
création du fichier /app/default_values/colors.js

utilisation de ces 2 fichiers dans routers/user.js avec la mise en place de la route Login User

correction dans models.user.js
    userSchema.methods.ToJSON
par 
    userSchema.methods.toJSON

tests via Postman, lors du login, si pas d'options enregistrées pour cet user -> on envoie les options par défaut --> nickel

création des routes Logout User et LogoutAll User
vérif via postamn que les tokens sont bien effacés comme prévu

création du fichier src/routers/options et ajout de la route Options List

modification dans app/src/index.js de la route 404 : ajout de l'envoi du status 404 avec la page


ci-dessous annulé:
ajout de la route /login dans src/index.jsje sais que ça devrait être dans routers/users/ mais je veux juste faire un rendu d'un partial et c'est beacoup plus simple si pas dans un nested router, surtout qu'ici je vais envoyer le formulaire et un lien vers la route /signin

nan je vais plutôt tout envoyer (les deux formulaires) avec src/index.js planquer les formulaires et faire de chouettes transitions avec les clics sur les divs de la nav, du genre :

svg login     Connexion
    caché / affichage en déroulant (ou autre si mieux ^^) :
    formulaire de log
svg signin    Nouveau Joueur
    caché / affichage en déroulant (ou autre si mieux ^^) :
    formulaire de création de compte
svg jouer     Jouer
    caché / affichage en déroulant (ou autre si mieux ^^) :
    Attention jeux restrain, juste pour test, sûr ?
svg help      Aide
    caché / affichage en déroulant (ou autre si mieux ^^) ou lien vers /help ???

et si le jeu est choisi, on affiche juste un petite roue crantée qui permettra de réafficher la nav bar avant une fin de partie

mise en place d'un fullscreen toggle dans la barre de titre :
création du template partiel header.hbs
création du fichier /public/js/fullscreen-toggle.js
création du fichier /public/scss/header.scss


ajout nav bar pour user non loggué :
création fichier templates/partials/navNotLogged.hbs
création fichier public/css/user-not-logged.scss


création fichier public/js/nav-not-logged.js
création fichier public/css/variables.scss
et mise en forme avec couleurs de la page d'accueil


Déplacement du contenu du fichier public/js/nav-not-logged.js ver le nouveau fichier public/js/navbars.js
Ce script est en commun à toutes les navbars et sert uniquement à afficher leur contenus

ajout dans navbars.js, desselection si reclic sur bouton de nav

modif de navbars.js pour en faire une constante appelable à chaque fois que l'on change de navbar

ajout requête post pour /user/login dans public/js/nav-not-logged.js 
modif routers/user.js pour gestion de partial template
Création du partial navLogged.hbs juste pour test le token
c'est ok


modif du contenu de navLogged.hbs, de nav-not-logged.js et user-not-logged.scss

modif du style de la div #welcome (accueil nouvel inscrit ou joueur juste après login)

renommé le fichier user-not-logged.scss en navbars.scss puisque pour les 2 navbars =)


ajout vérification de la disponibilité de sessionStorage sur le navigateur via public/js/is-storage-available.js et une petite partie dans public/js/index.js


Ajout requêtes /users/logout et /users/logoutall dans public/js/nav-logged.js

Création du fichier /src/utils/compute-grid-solution.js
Création du fichier /src/utils/compute-helpers.js

Création du fichier src/routers/grid.js de la route /grid/test-play

modif div Jouer dans nav-not-logged (class="button" et modif scss)

Ajout d'un svg (gear) dans le header qui servira à afficher/cacher la navbar lors d'une partie ou pendant le parcours des grilles
Création du fichier public/js/toggle-navbar.js
ajout remise en forme de la navbar lors d'un clic sur toggleNavbarBtn

mise en place de la requête /grid/test-game dans public/js/nav-not-logged.js

création du fichier css-variables.js et de la méthode permettant de calculer la taille de la grille en fonction de la taille de l'écran
ajout gestion de non status 201 sur cette requête

Création du fichier public/js/gameboard-builder.js

Création du fichier public/js/game-manager.js
ce dernier servira a fabriquer la grille, recalculer les variables css de taille de grille en cas de changement de la taille de l'écran (redimentionnement sur pc, changement d'orientation sur mobile/tablette), observer l'évolution de la grille pour savoir s'il faut envoyer la grille au serveur ...

Modif dans création html de grille, gameboardDiv maintenant dans mainContent

Création du fichier public/css/gameboard.scss

Ajout des boutons de choix de réponse dans index.hbs et mise en place de leur réaction au clic

Cache ces boutons si pas en partie.

Ajouté: bordure plus grosexit
se toutes les 5 cases de la grille verticalement.

Ajout réaction au clic de case de la grille.

Retiré : affichage du context menu si clic droit, sélection de texte via clic gauche déplacé et mouvement d'écran si touchmove (écrans tactiles)

retiré : scroll de page si clic sur bouton du milieu de la souris

Ajout gestion victoire si test-game

gestion des bouton de fermeture et de nouvelle grille de victoryDiv

ajout éclairage des headers de la grille au survol de case par la souris, dans public/js/gamemanager.js

création de la croix de navigation pour la grille

repositionnement des boutons de jeu pour mobile

retiré le bug qui enlevait la couleur d'une tuile lors d'une sélection multiple 

ajout déselection multiple sans modif des autres choix que celui en cours

cache la croix pour la grille si clic sur bouton fermer de Victory

ajout gestion de isUsingCross (game manager)

gestion du onhover sur les cases de la grille en js en ajoutant un classe, plutôt qu'un css tile:hover, pour ne pas modifier l'affichage de la case en cours lors d'un survol de souris si utilisation de la croix ( ou du peut-être un jour du gamepad ;) )
j'en ai profité pour modifier la gestion du nettoyage du css cols ou rowheaders.enlight coté js
De plus refactorisation du code en virant le tile.addEventListener('mouseover') et en utilisant son code dans tile.addEventListener('mouseenter')

réécriture de la croix de nav de la grille en un seul svg au lieu de 4, permettant ainsi son redimentionnement si .not-in-use

retiré : l'incrémentation du nbr de clic si isRemovingChoice ou si old choice != default et changement pour no ou maybe-no

Ajout selection de case avec la game cross

début utilisation game cross, pas convainquant, une seule case à la fois ...

résolu bug qui empéchait la sélection d'un bouton de couleur sur écran tactile (du au event.preventDefault() sur un touchstart qui empéchait l'event click d'être lancé)

modification game cross : maintenant la case sélectionnée change régulièrement lors d'un appui long

amélioration game cross : changement de choix sur les cases si appui long sur un choiceButton et sur la croix

ajout : comptage du nombre de 'clic' en utilisant la game cross
bug: 
    _ deux cases selected lors d'un rappel de partie en test depuis le menu principal après victory (que sur phone ?)
    _ pire la deuxième bouge toute seule apres appui long ...


Création branche dev

création branche testeventfunctions
j'y ai testé l'utilisation de function pour le addEventListener pour pouvoir utiliser des removeEventListener, 
ça fonctionnait mais juste une fois ...


bascule sur la branche dev
bug réglé ! maintenant il semble qu'on peut utiliser la croix correctement =)
pb, je trouve le code super moche !! faudra voir à regarder ça à nouveau ...

tentative sur dev d'ajouter la selection de plusieurs case avec un seul mouvement de doigt ... marche pas ...
je crois bien que la soluce va être de calculer le point d'arrivée du doigt puis la longueur de déplacement, et calculer quelles sont les cases touchées en cours de route ...

gestion de la route post /users (register user) coté front (sauf gestion retour des erreurs)

Création des modèles grid, userTimeEasy et userTimeHard

Ajout de la route /grid/new
création du modèle startTime pour enregistrer l'heure de début de jeu sur une grille pour un joueur

modification formulaire nouvelle partie dans user-loggued.js

pour l'instant je vais forcer à jouer uniquement sur des grilles carrées ...
mise en place rowsNb = colsNb coté front avec le formulaire nouvelle partie de user-logged.js
idem coté back avec ajout de forceSquareGrid dans routers/grid.js

gestion de la requête /grid/new dans user-logged.js

ajout vérif de grille pour si user logged, on va vérifier que les nombres de cases par ligne/colonne correspondent avec les totaux des headers. mais ça devrait pas être définitif, il faudra l'echanger par un contrôle des correspondances entre les helpers et la réalité de la grille, pas juste le nombre total correspondant. 
Pour faire plus simple encore, j'ai utilisé le nombre de clics pour une partie sans faute (clicksNbForPerfectGame)

modif : ajout l'envoi de grid._id depuis la route /grid/new et réception dans nav-logged.js puis game-manager.js

Ajout : route /grid/check pour vérifier les grilles finies par les joueurs

Correction bug : dans la route /grid/new on récupérait une grille déjà jouée

Ajout public/js/failed.js
    pour les partie envoyée au serveur mais fausse

Ajout gestion fetch pour /grid/check

correction bug : si user not logged et redemande test-game depuis victory, il fait autant d'appel que de fois où l'on a appuyé sur 'encore' ... : 
    retiré victoryPlayAnother.addEventListener('click'..  de la méthode watchVictoryBtns()

Déplacememnt du fetch /grid/new de nav-logged.js dans une constante à part pour pouvoir l'appeler depuis victory.
Ajout gestion bouton nouvelle partie si isUserLogged avec appel de cette constante nouvellement crée.

Création d'un partials : rules.hbs
    j'y afficherai les règles du jeu et les infos via des onglets séparés,
    pour l'instant juste quelques infos

Reconstruction complète de l'ancienne partie 'Règles':
Création des partial views : social, rules, infos et feedback
    maintenant l'onglet global 'Infos et +' laisse apparaître 3 sous-menus : Règles, Infos et Messages

Ajout contenu à partials/feedback

Création du partial messages.hbs : il servira à afficher les feedback envoyés par les joueurs.

Création du modèle Feedback, qui permettra d'enregistrer les messages des joueurs en BDD

Création du router feedback.js

modif : ajout possibilité de réponse aux feedbacks

implémenté : seul le créateur d'un message peut voir le bouton de suppression de message

modification du modèle User pour y inclure le field role non obligatoire qui permettra de faire des vérif si admin dans un premier temps (d'autres peut-être plus tard si besoin).

correction coquille : timestamps au lieu de timeStamps: true dans les modèles

Ajout route /feedback/list

Résolution d'un bug : lorsque l'on envoye une variable à une vue hbs, si on veut accéder à cette variable dans une boucle il faut précéder la variable avec ../
ça expliquera à handelbars que le scope privé dans lequel se trouve la variable est dans le scope parent
exemple : {{#ifEquals ../user.role "admin"}}

export du scss des formulaire dans un fichier à part : forms.scss

Création de public/js/feedback.js pour afficher/cacher le formulaire d'envoi de feedback

réécriture du html des 2 navbars : mise en place Règles pour les 2 et Entre nous pour user loggué, ce dernier contient Infos, Nouveau message et Vos messages. reformulation des hbs correspondants

Création d'une pop-up pour les notifications, sera appelée à chaque fois que j'aurai besoin d'envoyer une notif à un joueur

Création de la section tutos (tutos.hbs), et changement de quelques svg

Création de la section options (options.hbs)
    il me semble que je l'avais déjà créée puis effacée ...
+ quelques corrections de texte dans rules et tutos

Modifs : des gestions de retours de fetchs qui utilisaient la div welcome pour les messages, remplacement par des notifications avec un sendNotification()
    pour users/login  /users (register)  /users/logout  /users/logoutall

modif: utilisation de la div #no-js si JavaScript désactivé

Modif model user : ajout des propriétés visits, playedGrids et finishedGrids
modif également des route qui amènent des changements à ces valeurs

Ajout des boutons erase-all et erase-maybes 

Ajout gestion de formulaire d'envoi de feedback, si le type de feedback choisi est bug, alors l'utilisateur doit également renseigner son matériel et le navigateur utilisé

gestion des erreurs des formulaires de login et register

Ajout requête /feedback/list coté front

Début mise en page des messages envoyés par les joueurs


Création de la branche testmoment pour essayer de modifier le format des date avant envoi vers navigateur
cool ça marche, c'est pas fni, pour l'instant je force en fr
pour git donc ce sera : Ajout utilisation moment js

Création du formulaire de réponse aux feedbacks
Amélioration du style de l'affichage des feedbacks

Gestion complète des réponses aux feedbacks par un admin : route, requête et style

modif: gestion des erreurs d'envoi de formulaires

modif: ajout propriété status aux modèles User et Feedback

modif des partials views tutos et rules, afin d'avoir une petite base avant mise en ligne de la version alpha.
                                
multiples modifs :
utilisation plus grande de la classe in-game avec #main-title
ajout d'une div : #game-zone contenant la grille et les boutons de jeu

quelques correction du css

netoyage du code pour mise en ligne de la version alpha 1.0.0

Ajout du partial trash can.hbs, correspond au pop up qui apparaît lors du clic sur la poubelle visible pendant une partie.
prob pour l'instant , je ne sais pas comment faire avec cette poubelle ...

modif du modèle Grid: ajout propriétés nbTimesPlayed et nbTimesFinished

remodif du model Grid, les prop créent juste avant sont dédoublées pour inclure easy ou hard

Ajout du modèle RefusedGrid, servira à vérifier que le joueur n'a pas déjà refusé cette grille, avec comme propriété easy et hardStatus ('once', 'confirmed', 'definitive' ou 'forever') pour permettre un affichage spécifique dans la liste des grilles si déjà refusée par le joueur
modif des models Grid et User pour les ref dans refusedGrid

modification de routers/grid.js pour y inclure la gestion du model RefusedGrid

correction erreur dans routers/grid 

Création de la route '/grid/trashcan'

Création et gestion de la requête pour '/grid/trashcan'

Ajout d'un favicon grid svg de bootstrap avec léger chagement dans son code pour qu'il puisse changer de couleur selon si le navigateur est en mode sombre ou non, voir public/favicon.svg

Ajout d'un gif animé dans la section Règles, en espérant que ce sera assez clair ...

Ajout de DotEnv pour gérer les variables critiques, permettra aussi de ne pls être ennuyé avec l'adresse de hostname différente entre mon poste de dev et la prod

Ajout dans Readme.md le process pour lancer l'appli

Modif du chemin d'utilisation de .env

correction coquille 'graille' au lieu de 'grille' dans tuto.hbs

Correction de bug : sur grand écran, lorsque l'on lance une partie, la grille est trop grande et force à  scroller ... : déplacement de l'appel de setCssGridSize() dans game-manager.js juste après gameZone.classList.remove('d-none');

Correction de bug : Uncaught ReferenceError: crossAction is not defined
    at SVGGElement.<anonymous> (game-manager.js:405)
(tactile) : si on appuye sur la croix alors que la croix n'est pas activée, l'erreur se lance qd on relache.
Coller une variable genre isActivatingGamecross ? non, pas fait come ça, pas envied 'ajouter une variable alors que isUsingCross existe déjà ... du coup, j'ai déplacé une partie de gameCross -> touchstart vers gamecross -> touchend + ajout d'un preventDefault() sur tile -> touchmove (on ne scroll pas depuis la grille)

modif: déplacement de la poubelle de refus de grille

modif: meilleur placement de la gamecross et des boutons de jeu 

modif : compression du fichier tuto-grille.gif

modif : !! soucis de sécu repéré !! 
la route /users/list est accéssible à tous avec une méthode style Postman ... il n'y a même pas de auth ...
donc modif : ajout de la vérif de user logged et surtout user est un admin ;)

modif : léger changement des règles en ajoutant la description du jeu (1er ligne)

modif de l'introduction dans infos.hbs

Création du partiel 'new info.hbs' qui contient le formulaire d'ajout d'information de nouvelle version et de son style avec nouveau scss : infos et dans forms.scss

Création du modèle Info

Création fichier src/routers/info.js et de la route /infos/new
et ajout de message d'erreur dans le model pour les propriétés required

Création du fichier public/js/infos.js
ajout gestion afficher/cacher le formulaire de nouvelle version (ou info comme on veut)
ajout d'un bouton d'annulation du formulaire

Modif de la route /infos/new

Modif du html concernant l'affichage des infos

Création de la requête /infos/new
et remodification de la route du même nom

modif du style pour les headers d'info

Ajout : envoi des titres d'infos lors de la connexion du joueur
ces infos seront précédées d'un ! sur navigateur si celles-ci ont étées enregistrées depuis la dernière visite du joueur, ainsi que les titre correspondant pour que le joueur soit au courant de la présence de nouveauté

Création de la route /infos/one
cette route permet d'afficher le message contenu dans l'info demandée

Création de la requête /infos/one 
la flèche dans le header de l'info sert de déclencheur, à réception du message elle se tourne vers le bas et le message s'affiche

Gestion effacement des ! annonçants une nouvelle info

modif : ajout du cursor: pointer quand nécessaire



POUSSE VERS GIT AVEC LE TAG 2020-09-14

contenu du message associé sur le site en prod :
titre: Ajout des informations de nouvelle version

Ajouts :
  - maintenant les modifications du site seront affichées ici
  - possibilité de refuser une grille si vous la trouvez trop dure
  - favicon pour l'onglet du navigateur

Modification :
  - du texte des règles du jeu, j'ai également ajouté un gif animé qui vous donne un exemple de remplissage de grille

Correction de bug :
  - grille trop grande sur grand écran
_____________________________________________________________________________________________



Résolution de bugs: affichage des messages d'infos sur une seule ligne ! les 'retour chariot' dans un textarea sont des /r/n, je les remplace maintenant par des <br> à réception dans le routeur. problème, le même bug est présent avec le textarea des feedbacks, la réaction à l'enregistrement en bdd semble différent o_O, il ne me renvoie que des &lt;br&gt; non pris en compte par chrome 
résolution de bug : il manquait un watchInfo() après création d'une nouvelle info
J'en ai profité pour en mettre un aussi à la création de compte

modif: ajout sur les schémas de modèles des trim manquants sur certaines String

Résolution de bug : si clic sur la croix de fermeture dans Victory, effacer la poubelle de grille

résolution bug : cache/affiche la poubelle de grille si accès à la navbar/retour à la grille

Création de la route /infos/update/one

Modif model Info: tri des infos par date de création

Ajout d'un svg dans infos.hbs, seulement si admin pour afficher modif info

Ajout du partial 'info change.hbs'

Création de la requête /infos/update/one : bugguée !!! ajoute de multiples <br> pour chaque saut de ligne ... 
    désactivée coté front dnas /public/js/infos.js par un return sendNotification()
    coté back par un return res.send('fonctionnalité désactivée');
    ai tenté d'utiliser br2nl() dans public/js/infos.js

Création de la route /info/delete

Ajout svg poubelle pour chaque info (seulement pour admin)
Ajout div de confirmation d'effacement d'info
Ajout de la div de confirmation d'effacement d'info dans 'infos global.hbs'
ajout afficher/cacher la div de confirmation d'effacement d'info
Ajout de la requête /infos/delete
obligé de faire dans public/js/infos.js, une nouvelle watchNewInfos() et d'y exporter tout le code pour les boutons qui se rechargent avec la création, la modification ou l'effacement des infos

Correction bug : après ajout nouvelle info, les bouton poubelle et crayon n'apparaîssent pas




POUSSE VERS GIT AVEC LE TAG 2020-09-15

contenu du message associé sur le site en prod :
titre: Ajout des informations de nouvelle version

Corrections de bug :
 - affichage du message des infos sur une seule ligne.
 - bouton d'affichage des contenus d'infos non fonctionnels après création d'une nouvelle info
 - poubelle de grille toujours présente lors d'un retour à la barre de navigation

Ajouts :
  - possibilité de modifier une info (admin seulement) (bugguée pour l'instant) -> désactivé
  - possibilté d'effacer une infos (admin seulement)
_____________________________________________________________________________________________




grosse amélioration de la div Victoire :
installation du module npm moment-duration-format
modif index.hbs dans la div Victoire, ajout structure pour afficher de nombreuses autres infos : chrono du joueur, son meilleur temps, le record du monde, le classement du joueur et les nombre de fois où la grille a été jouée et finie.
modif du style pour que ce soit un peu plus chouettte
modif router grid pour traiter et renvoyer les nouvelles données
modif game-manager pour renvoyer les données reçue en fetch vers victoire()
modif victoire.js pour traiter le tout
J'ai fait le CHOIX de gérer toutes ces infos coté front au lieu de faire une vue partielle pour soulager un peu le serveur qui a déjà un gros taf (surtout si bcp de grilles jouées par bcp de joueurs)

ajout de ce code dans grid router /grid/new :
    console.log(req.body.rowsNb)
    if (req.body.rowsNb == 11) {
        console.log('modif en cours')
        try {
            const grids = await Grid.find({});        
            for (let i = 0, max = grids.length; i < max; i++) {
                if (grids[i].hardNbTimesPlayed < grids[i].hardNbTimesFinished) {
                    if (i === 0) {
                        grids[i].hardNbTimesPlayed = 6;
                        if (grids[i].hardNbTimesPlayed < grids[i].hardNbTimesFinished) {
                                grids[i].hardNbTimesPlayed = grids[i].hardNbTimesFinished;
                            }
                    }
                    else if (i === 1) {
                        grids[i].hardNbTimesPlayed = 4;
                        if (grids[i].hardNbTimesPlayed < grids[i].hardNbTimesFinished) {
                                grids[i].hardNbTimesPlayed = grids[i].hardNbTimesFinished;
                            }
                    }
                    else {
                        grids[i].hardNbTimesPlayed = grids[i].hardNbTimesFinished;
                    }
                    await grids[i].save();
                }
            }
            console.log('tout est ok ! BDD mise à jour =)')
        }    
        catch(e) {
            console.log('erreur')
            console.log(e)
        }
    }
ça m'a permis de remettre les compteurs de grilles jouées à niveau (manquait incrémentation nbr grilles jouées ...)




POUSSE VERS GIT AVEC LE TAG 2020-09-17

contenu du message associé sur le site en prod :
titre: Amélioration du message de victoire

Ajouts nombreux dans la fenêtre de victoire :
  - chrono du joueur
  - son meilleur chrono si grille rejouée en moins rapide
  - record du monde
  - détenteur du record
  - classement du joueur pour cette grille
  - nombre de fois où la grille a été jouées et finies par l'ensemble des joueurs
_____________________________________________________________________________________________




légères modif css : affichage de p-e oui au lieu de may-be yes et les autres

Destructuration du header : modif HTML et CSS pour mise en place correcte des boutons reset grid et reset maybe : en plusieurs commits :

création #grid-options
renommé #trash-can-btn en #grid-trash-btn, déplacé dans #grid-options

Déplacement de svg#toggle-navbar

Déplacement de #go-fullscreen et #exit-fullscreen

Ajout des boutons #reset-grid-btn et #maybe-reset-btn, mise en place de leur actions (remise à zéro du contenu de la grille et effacement des maybe)

Modification de classe des notifications: de success, info et error vers notif-success, notif-info et notif-error
ajout d'une bordure à la notification

ajout classe not-implemented au bouton choisir grille de Victory




POUSSE VERS GIT AVEC LE TAG 2020-09-20

contenu du message associé sur le site en prod :
titre: Ajout de boutons reset

Ajouts :
  - un bouton orange pour remettre la grille à zéro. Situé sous la poubelle de grille, il efface toutes les réponses données aux cases de la grille.
  - un bouton jaune pour effacer les peut-être, son rôle est de redonner la couleur d'origine aux cases cochées avec 'peut-être oui' ou 'peut-être non' sans modifier les cases cochées 'oui' ou 'non'

Attention, un clic sur ces boutons n'est pas comptabilisé comme un coup, cependant le nombre de coups pour cette grille n'est pas remis à zéro.
_____________________________________________________________________________________________



modif: width: 100% au lieu de 100vw pour h1 sinon, ascenseur horizontal

Création de la branche 'responsive'

mise en place style ingame pour landscape phone

modif du calcul de gameboardWidth dans css-variables.js

Correction bug : 
    maintenant après une partie avec la croix, cette dernière reste sélectionnée pour la partie suivante.
    maintenant après une fin de partie sans gamecross et dernière sélection avec maybe-yes, pour la partie suivante le bouton yes s'auto-sélectionne et surtout s'affiche comme sélectionné

Ajout de remplissage automatique de cases 'non' si les cases 'oui' d'une ligne ou d'une colonne correspondent aux helpers

Ajout remplissage automatique idem mais avec utilisation de la croix

Ajout du scanning de code proposé par Github : CodeQl Analysis

Modif : Réduction du temps des notifications à 5 secondes




POUSSE VERS GIT AVEC LE TAG 2020-10-19

contenu du message associé sur le site en prod :
titre: Ajout remplissage auto des cases 'non'

Corrections de bug :
  - maintenant après une partie avec la croix, cette dernière reste sélectionnée pour la partie suivante.
  - maintenant après une fin de partie sans gamecross et dernière sélection avec maybe-yes, pour la partie suivante le bouton yes s'auto-sélectionne et surtout s'affiche comme sélectionné.

Modification :
  - Réduction du temps des notifications à 5 secondes.

Ajouts :
  - remplissage automatique de cases 'non' si les cases 'oui' d'une ligne ou d'une colonne correspondent aux helpers
  - ingame : mise en place du style pour téléphone en position horizontale 
_____________________________________________________________________________________________














A REFAIRE POUR LA VERSION BETA :
_ modif du model Grid : faire les ref correctement ?
ça entraine l'effacement complet en bdd de toutes les données relatives ... mais pas très grave de revenir à zéro pour la beta 


a faire aussi : 
- améliorer le style des infos ...







pour les infos : 
_ le hbs avec la var hasNewContent
_ la route 
    calcul de hasNewContent en comparant la date de dernière visite avec les dates des contenus
non !    pour savoir à quelle date un user s'est connecté, il suffit de regarder user.updatedAt ;)
_ les requêtes :
    - /infos/new            pour ajouter une nouvelle info
non !    - /infos                pour lister toutes les infos (enfin on chope pas tout ... seulement _ids, titres et dates)
    - infos/one             pour avoir la totalité de l'info demandée par _id
    - infos/update-one      pour en modifier une (ici la requête n'est pas post mais patch)
    - infos/delete-one      pour en effacer une (ici la requête n'est pas post mais delete)






PRIORITAIRE :
_  AJOUTER RIRIGRAM SUR LE PORTFOLIO EN ZONE Projet en cours. ???
Et renommer Ririgram en Ririgram v1
_ remplir la zone Tutos
_ le cheat ?
_ les bugs






bug: 
_ pour /infos/delete , retour avec une erreur 500 sans message si l'info à effacer n'existe pas !
_ juste après enregistrement d'une nouvelle info, si on veut voir une info :
    info.js:196 Uncaught TypeError: Cannot read property 'classList' of null
    at SVGSVGElement.<anonymous> (info.js:196)
_ les infos ne sont pas livrées si création d'utilisateur



A faire : 
_ dans dotenv, coller un FIRST_ADMIN_NAME ou ADMIN_NAME pour faire la vérif pour le premier admin et du coup modif du readme pour y coller l'infos après #Launch
_ pour les infos : ! bien réfléchir au model pour ne pas modif le bdd en prod !
le model : _id, version(String), title(String), info(string)
l'idée c'est de n'envoyer que les titres et dates des infos, et d'appeller le contenu uniquement si clic sur un bouton
_ dans les fetch, coller un catch avec sendNotification -> 'il y a un problem pour joindre le serveur ou autre chose du genre
_ manque vérif du type de feedback coté serveur !!!!!!! o_O

_ pour donner une idée de la difficulté d'une grille: 
    modif du model grid : ajout des propriétés nbTimesPlayed (nombre de fois présentée aux joueurs), nbTimesFinished

_ Ajouter  models :
    - bannedGrid : les grilles refusées par un grand nombre ET pourcentage de joueurs (donc pas super urgent ^^)
        _id, gridId

_ bouger la croix et les boutons de jeu





Cheat:
_ loggué: on charge une grille, puis via navbar demade de nouvelle grille, il prend la dernière enregistrée non finie, donc la même.
ça c'était prévu, il manque la vérif de l'envoi de cette grille au joueur dans les dernières 24h.
oups, je crois que j'ai effacer des startTime dans un autre cas que grille réussie
A vérifier
Mais du coup, c'est pas un cheat mais une feature non finie ;)






// !!! Ne pas oublier d'ajouter 'Bearer ' devant les tokens coté front avant de les envoyer au serveur !!!!


pour lancer mongodb :
    /home/vagrant/mongodb/bin/mongod --dbpath=/home/vagrant/mongodb-data
pour lancer l'appli
    node src/index.js
ou 
    npm run start



users during dev :
{
    "name": "Circus",
    "email": "test@test.fr",
    "password": "1234567",
    "role": "admin"
}

{
    "name": "Circus2",
    "email": "test2@test.fr",
    "password": "1234567"
}

{
    "name": "Circus3",
    "email": "test3@test.fr",
    "password": "1234567"
}



todos :
_ dans la liste des grilles, coller une croix dans le colonne déjà jouée par  le joueur si mise à la poubelle (la croix pourrait être jaune, orange, rouge (noir pour forever ?) selon le nombre d'essais refaits en passant par cette page)
_  BDD : 
    - User : utiliser la propriété  status (par ex pour bloquer si faute extrèmement grave)
    - Feedback :  utiliser propriété status (boquer ce message -abus grave-) 
    -> ajouter les boutons nécessaires
_ vérifier la gestion des erreurs, il reste dans les routers dans les catch des erreurs réécrites avant d'être envoyées ... 
_ lors d'une erreur de validation de form par le model, il ajoute une phrase du genre 'User validation failled: Email: et ma phrase..." faut voir pour virer ce début ...faire un test de présence de User et virer ce ui est en trop, voir aussi les autres models
_ récupérer les deux letttres de la locale du joueur pour lui afficher les dates dans sa langue
_ dans user register : gérer le message d'erreur si plusieurs pb ? genre pseudo et email invalide en même temps
_ un joueur ne devrait pas avoir 2 fois la même grille en moins de 24 heures, que ce soit avec le choix de grille ou avec une nouvelle (nouvelle veut dire pas de chrono enregistré)
_ dans les options, coller un curseur pour choisir la vitesse de défilement des cases si utilisation de la game cross
_ faire une requête après réception du résultat positif de test de grille et envoyer le vote pour la grille
_ écrire la méthode checkTileHeaders() dans public/js/game-manager.js pour modif la couleur des helpers qd correspodant à la grille et utiliser une correspondance complète pour envoi de la grille au serveur pour vérif.
    une fois fait, retirer clicksNbForPerfectGame de l'envoi en res du serveur dans la route /grid/new, plus besoin de lui ;); le retirer aussi dans nav-logged.js, dans newGdridForm -> submit. --attention-- ne pas le virer en réception coté front dans gamemanager ... on s'en sert avec test-game.
_ ajouter la gestion d'un gamepad pour faire comme la croix mais sur pc ? ce serait top !
_ ajouter : message d'erreur : cet email est déjà enregistré (models/use.js ) déjà fait et pourtant fonctionne pas ...
_ ajouter retour vérif création new user, qd name existe on a pas le mesage d'erreur perso mais e.code = 11000 et e.keyValue = { name: 'Circus' } je devrais pouvoir utiliser ça
_ ajouter si login, vérif token car on ne devrait pas avoir accès au form de login une fois loggué -> avertissement pour pratique étrange ? -> ban ip, email  pour un temps -> ban ip, email pour toujours ?
_ gràce au token, faire un se souvenir de moi ? 
    au moins coller une date d'expiration sur les tokens
_ ajouter dans nav-not-logged : mot de passe oublié avec envoi mail de confirmation
_ ajouter gestion des erreurs form login (et les autres)


idées: 
_ Victory : 
    au lieu de faire des phrases, faire quelque chose comme ça ? :

    Nbr de coups : 19
    |
    |-> Sans faute : Check    (ou perfect game ?)
    ou  Nbr coups mini : 17

    Chrono : 1'25''365
    |
    |-> Record du monde : Check
    ou  Record du monde : 1:22:654
        par Duchnock
        ta position : 5/16
    ou  rien si premier chrono pour cette grille

    nbXjouées
    nbXfinies

    un bouton pour avoir toutes les données relatives à cette grille :
        Joueur chrono nbCoups nbXjouées nbXfinies
_ Améliorer la recherche de nouvelle grille, car l'array contenant les grilles exsistantes peut vite devenir beaucoup trop grosse.
Lorsque ce sera le cas ne rechercher que les grilles ayant une date postérieure à la dernière jouée. pb : pas envie de tuer la bdd parce que je modifie une nouvelle fois une collection en ajoutant des fields non prévus ... soluce : capter comment on fait ça sans effacer la bdd et surtout sur un serveur en prod ! lol je sens que ça va être fun ça !
On pourrait aussi lancer la récup des grilles existantes par pacquets



Pourquoi MongoDB et pas du sql ?
Pour voir comment ça tient le coup une fois un grand nombre de grilles finies avec cette méthode de création de grille (voir /src/routers/grid.js route '/grid/new').
Il serait d'ailleurs super intéressant de comparer avec du sql et un symfony par exemple.